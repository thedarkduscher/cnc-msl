
    <!DOCTYPE html>
    <html>
        <head>
            <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro" rel="stylesheet">
            <link rel="stylesheet" href="style.css">
        </head>
        <body>
            <div id="sidebar">
                
    <h3>Namespaces</h3>
    <ul class="namespaces">
        <li ><a href="namespaceaccelMax.html">accelMax</a></li>
        <li ><a href="namespaceAdafruit__GPIO.html">Adafruit_GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1FT232H.html">Adafruit_GPIO::FT232H</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1GPIO.html">Adafruit_GPIO::GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1I2C.html">Adafruit_GPIO::I2C</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1MCP230xx.html">Adafruit_GPIO::MCP230xx</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PCF8574.html">Adafruit_GPIO::PCF8574</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1Platform.html">Adafruit_GPIO::Platform</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PWM.html">Adafruit_GPIO::PWM</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1SPI.html">Adafruit_GPIO::SPI</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master.html">Adafruit_LSM9DS0-master</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0__example.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0_example</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Fuse__LSM9DS0.html">Adafruit_LSM9DS0-master::Fuse_LSM9DS0</a></li>
        <li ><a href="namespacealica.html">alica</a></li>
        <li ><a href="namespacealicaAutogenerated.html">alicaAutogenerated</a></li>
        <li ><a href="namespaceautodiff.html">autodiff</a></li>
        <li ><a href="namespaceBlackLib.html">BlackLib</a></li>
        <li ><a href="namespacecambada.html">cambada</a></li>
        <li ><a href="namespacecambada_1_1geom.html">cambada::geom</a></li>
        <li ><a href="namespacecambada_1_1loc.html">cambada::loc</a></li>
        <li ><a href="namespacecambada_1_1util.html">cambada::util</a></li>
        <li ><a href="namespacecastor.html">castor</a></li>
        <li ><a href="namespaceCNMC__Debug__Client.html">CNMC_Debug_Client</a></li>
        <li ><a href="namespaceCNMC__Debug__Client_1_1Properties.html">CNMC_Debug_Client::Properties</a></li>
        <li ><a href="namespacecompassCalib.html">compassCalib</a></li>
        <li ><a href="namespacecomplete.html">complete</a></li>
        <li ><a href="namespacedoxy2swig.html">doxy2swig</a></li>
        <li ><a href="namespaceez__setup.html">ez_setup</a></li>
        <li ><a href="namespaceFtdi.html">Ftdi</a></li>
        <li ><a href="namespacegazebo__msgs.html">gazebo_msgs</a></li>
        <li ><a href="namespacegeometry.html">geometry</a></li>
        <li ><a href="namespacegeometry__msgs.html">geometry_msgs</a></li>
        <li ><a href="namespacei2c-test.html">i2c-test</a></li>
        <li ><a href="namespaceList.html">List</a></li>
        <li ><a href="namespacelsm-test.html">lsm-test</a></li>
        <li ><a href="namespacemsl.html">msl</a></li>
        <li ><a href="namespacemsl__actuator__msgs.html">msl_actuator_msgs</a></li>
        <li ><a href="namespacemsl__helper__msgs.html">msl_helper_msgs</a></li>
        <li ><a href="namespacemsl__joystick.html">msl_joystick</a></li>
        <li ><a href="namespacemsl__msgs.html">msl_msgs</a></li>
        <li ><a href="namespacemsl__ptgrey__camera.html">msl_ptgrey_camera</a></li>
        <li ><a href="namespacemsl__refbox.html">msl_refbox</a></li>
        <li ><a href="namespacemsl__sensor__msgs.html">msl_sensor_msgs</a></li>
        <li ><a href="namespacemulticast.html">multicast</a></li>
        <li ><a href="namespacesensor__msgs.html">sensor_msgs</a></li>
        <li ><a href="namespacesetup.html">setup</a></li>
        <li ><a href="namespacesimple.html">simple</a></li>
        <li ><a href="namespacesplines.html">splines</a></li>
        <li ><a href="namespacestd.html">std</a></li>
        <li ><a href="namespacestd__msgs.html">std_msgs</a></li>
        <li ><a href="namespacesupplementary.html">supplementary</a></li>
        <li ><a href="namespaceSystem.html">System</a></li>
        <li ><a href="namespaceSystem_1_1Collections_1_1Generic.html">System::Collections::Generic</a></li>
        <li ><a href="namespaceSystem_1_1ComponentModel.html">System::ComponentModel</a></li>
        <li ><a href="namespaceSystem_1_1Data.html">System::Data</a></li>
        <li ><a href="namespaceSystem_1_1Drawing.html">System::Drawing</a></li>
        <li ><a href="namespaceSystem_1_1IO_1_1Ports.html">System::IO::Ports</a></li>
        <li ><a href="namespaceSystem_1_1Linq.html">System::Linq</a></li>
        <li ><a href="namespaceSystem_1_1Reflection.html">System::Reflection</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1CompilerServices.html">System::Runtime::CompilerServices</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1InteropServices.html">System::Runtime::InteropServices</a></li>
        <li ><a href="namespaceSystem_1_1Text.html">System::Text</a></li>
        <li ><a href="namespaceSystem_1_1Threading.html">System::Threading</a></li>
        <li ><a href="namespaceSystem_1_1Windows_1_1Forms.html">System::Windows::Forms</a></li>
        <li ><a href="namespacetests.html">tests</a></li>
        <li ><a href="namespacetests_1_1MockGPIO.html">tests::MockGPIO</a></li>
        <li ><a href="namespacetests_1_1test__GPIO.html">tests::test_GPIO</a></li>
        <li ><a href="namespacetests_1_1test__I2C.html">tests::test_I2C</a></li>
        <li ><a href="namespacetests_1_1test__Platform.html">tests::test_Platform</a></li>
        <li ><a href="namespacetests_1_1test__PWM.html">tests::test_PWM</a></li>
        <li ><a href="namespacetests_1_1test__SPI.html">tests::test_SPI</a></li>
        <li ><a href="namespacetinyxml2.html">tinyxml2</a></li>
        <li ><a href="namespacexmlpp.html">xmlpp</a></li>
    </ul>

            </div>
            <div id="content">
                
    <div class="compound class">
        <h1 class="title">Class <span class="accent">TCODBsp</span></h1>
            <div class="description">
        <div class="para">bsp  Roguelike toolkits  BSP toolkit  This toolkit allows to create and manipulate 2D Binary Space Partition trees. They can be used to split a rectangular region into non overlapping sub-regions. </div>
</div>
            
    <div class="section members">
        <h2>Public Members</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    x
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    y
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    w
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    h
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    position
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    horizontal
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        uint8
                    </span>
                    level
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
    </div>

            
    <div class="section members">
        <h2>Public Functions</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    TCODBsp
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
        <div class="para">bsp_init  bsp  Creating a BSP tree  Creating the root node  First, you have to create the root node of the tree. This node encompasses the whole rectangular region.  TCODBsp::TCODBsp(int x,int y,int w, int h)  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *TCOD_bsp_new_with_size(int x,int y,int w, int h)  bsp_new_with_size(x,y,w, h) # TCODBsp::TCODBsp(int x, int y, int w, int h)  x,y,w,h Top left corner position and size of the rectangular region covered by the BSP tree.  
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
;  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    TCODBsp
                    <span class="argsstring"> (int x, int y, int w, int h)</span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    removeSons
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
        <div class="para">bsp_init  Deleting a part of the tree  You can delete a part of the tree, releasing resources for all sub nodes with :  void 
    <a href="classTCODBsp_1a8942e17837013284425a0616ae04ad76.html">TCODBsp::removeSons()</a>
  void TCOD_bsp_remove_sons(TCOD_bsp_t *node)  bsp_remove_sons(node) # 
    <a href="classTCODBsp_1a8942e17837013284425a0616ae04ad76.html">TCODBsp::removeSons()</a>
  node In the C version, the node reference.  
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
; create a tree myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); clear it (keep only the root) myBSP->
    <a href="classTCODBsp_1a8942e17837013284425a0616ae04ad76.html">removeSons()</a>
; and rebuild another random tree myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f);  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); TCOD_bsp_remove_sons(my_bsp); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) libtcod.bsp_remove_sons(my_bsp) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    ~TCODBsp
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
        <div class="para">bsp_init  deleting the tree  You can also completely delete the tree, including the root node to release every resource used :  void 
    <a href="classTCODBsp_1a620f60223047a5a1f36f976af90bc863.html">TCODBsp::~TCODBsp()</a>
  void TCOD_bsp_delete(TCOD_bsp_t *node)  bsp_delete(node) # void TCODBsp::Dispose()  node In the C version, the node reference.  
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
; create a tree myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); use the tree ... delete the tree delete myBSP;  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); use the tree ... TCOD_bsp_delete(my_bsp);  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) <models.compound.docHeadingType object at 0x7fb3de910908>
</div>
        <div class="para">libtcod.bsp_delete(my_bsp) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    splitOnce
                    <span class="argsstring"> (bool horizontal, int position)</span>
                </div>
                    <div class="description">
        <div class="para">bsp_split  bsp  Splitting the tree  Splitting a node once  Once you have the root node, you can split it into two smaller non-overlapping nodes.  void 
    <a href="classTCODBsp_1a6b6221bf79a1d0aa2275fa2e04b751b1.html">TCODBsp::splitOnce(bool horizontal, int position)</a>
  void TCOD_bsp_split_once(TCOD_bsp_t *node, bool horizontal, int position)  bsp_split_once(node, horizontal, position) # void 
    <a href="classTCODBsp_1a6b6221bf79a1d0aa2275fa2e04b751b1.html">TCODBsp::splitOnce(bool horizontal, int position)</a>
  node In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.  horizontal If true, the node will be splitted horizontally, else, vertically.  position Coordinate of the splitting position. If horizontal is true, x <= position < x+w Else, y <= position < y+h  
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
; myBSP->splitOnce(true,20); // horizontal split into two nodes : (0,0,50,20) and (0,20,50,30)  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_once(my_bsp,false,20); // vertical split into two nodes : (0,0,20,50) and (20,0,30,50)  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_once(my_bsp,False,20) # vertical split into two nodes : (0,0,20,50) and (20,0,30,50) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    splitRecursive
                    <span class="argsstring"> (TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)</span>
                </div>
                    <div class="description">
        <div class="para">bsp_split  Recursively splitting a node  You can also recursively split the bsp. At each step, a random orientation (horizontal/vertical) and position are choosen :  void 
    <a href="classTCODBsp_1ac45a60808aa2f17d138cb10744b65ab2.html">TCODBsp::splitRecursive(TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)</a>
;  void TCOD_bsp_split_recursive(TCOD_bsp_t *node, TCOD_random_t randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)  bsp_split_recursive(node, randomizer, nb, minHSize, minVSize, maxHRatio, maxVRatio) # void TCODBsp::splitRecursive(TCODRandom randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)  node In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.  randomizer The random number generator to use. Use NULL for the default one.  nb Number of recursion levels.  minHSize, minVSize minimum values of w and h for a node. A node is splitted only if the resulting sub-nodes are bigger than minHSize x minVSize  maxHRatio, maxVRation maximum values of w/h and h/w for a node. If a node does not conform, the splitting orientation is forced to reduce either the w/h or the h/w ratio. Use values near 1.0 to promote square nodes.  Do a 4 levels BSP tree (the region is splitted into a maximum of 2*2*2*2 sub-regions). 
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
; myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f);  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    resize
                    <span class="argsstring"> (int x, int y, int w, int h)</span>
                </div>
                    <div class="description">
        <div class="para">bsp_resize  Resizing a tree  bsp  This operation resets the size of the tree nodes without changing the splitting data (orientation/position). It should be called with the initial region size or a bigger size, else some splitting position may be out of the region. You can use it if you changed the nodes size and position while using the BSP tree, which happens typically when you use the tree to build a dungeon. You create rooms inside the tree leafs, then shrink the leaf to fit the room size. Calling resize on the root node with the original region size allows you to reset all nodes to their original size.  void 
    <a href="classTCODBsp_1a4e1a2884ecf106f784f98a4525c65f08.html">TCODBsp::resize(int x,int y, int w, int h)</a>
  void TCOD_bsp_resize(TCOD_bsp_t *node, int x,int y, int w, int h)  bsp_resize(node,  x,y, w, h) # void 
    <a href="classTCODBsp_1a4e1a2884ecf106f784f98a4525c65f08.html">TCODBsp::resize(int x, int y, int w, int h)</a>
  node In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.  x,y,w,h New position and size of the node. The original rectangular area covered by the node should be included in the new one to ensure that every splitting edge stay inside its node.  We create a BSP, do some processing that will modify the x,y,w,h fields of the tree nodes, then reset all the nodes to their original size. 
    <a href="classTCODBsp.html">TCODBsp</a>
 *myBSP = new 
    <a href="classTCODBsp.html">TCODBsp(0,0,50,50)</a>
; myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); ... do something with the tree here myBSP->resize(0,0,50,50);  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); ... do something with the tree here TCOD_bsp_resize(my_bsp,0,0,50,50);  my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) <models.compound.docHeadingType object at 0x7fb3dea3d4a8>
</div>
        <div class="para">libtcod.bsp_resize(my_bsp,0,0,50,50) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
    <a href="classTCODBsp.html">TCODBsp</a>
 *
                    </span>
                    getLeft
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
        <div class="para">bsp_read  bsp  Reading information from the tree  Once you have built a BSP tree, you can retrieve information from any node. The node gives you free access to its fields :  class 
    <a href="classTCODBsp.html">TCODBsp</a>
 { public : int x,y,w,h; // int position; // position of splitting bool horizontal; // horizontal splitting ? uint8 level; // level in the tree ... }  typedef struct { int x,y,w,h; int position; bool horizontal; uint8 level; ... } 
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
; # class 
    <a href="classTCODBsp.html">TCODBsp</a>
 { public int x { get; set; } public int y { get; set; } public int h { get; set; } public int w { get; set; } public int position { get; set; } public bool horizontal { get; set; } public byte level { get; set; } }  x,y,w,h Rectangular region covered by this node.  position If this node is not a leaf, splitting position.  horizontal If this node is not a leaf, splitting orientation.  level Level in the BSP tree (0 for the root, 1 for the root's sons, ...).  bsp_read  Navigate in the tree  You can navigate from a node to its sons or its parent using one of those functions. Each function returns NULL if the corresponding node does not exists (if the node is not splitted for getLeft and getRight, and if the node is the root node for getFather).  
    <a href="classTCODBsp.html">TCODBsp</a>
 *TCODBsp::getLeft() const 
    <a href="classTCODBsp.html">TCODBsp</a>
 *TCODBsp::getRight() const 
    <a href="classTCODBsp.html">TCODBsp</a>
 *TCODBsp::getFather() const  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 * TCOD_bsp_left(TCOD_bsp_t *node) 
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 * TCOD_bsp_right(TCOD_bsp_t *node) 
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 * TCOD_bsp_father(TCOD_bsp_t *node)  bsp_left(node) bsp_right(node) bsp_father(node) # 
    <a href="classTCODBsp.html">TCODBsp</a>
 
    <a href="classTCODBsp_1ad64f971d48e6911a4b00383f497f4c6d.html">TCODBsp::getLeft()</a>
 
    <a href="classTCODBsp.html">TCODBsp</a>
 TCODBsp::getRight() 
    <a href="classTCODBsp.html">TCODBsp</a>
 TCODBsp::getFather()  node In the C version, the node reference. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
    <a href="classTCODBsp.html">TCODBsp</a>
 *
                    </span>
                    getRight
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
    <a href="classTCODBsp.html">TCODBsp</a>
 *
                    </span>
                    getFather
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    isLeaf
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
        <div class="para">bsp_read  Checking if a node is a leaf  You can know if a node is a leaf (not splitted, no sons) with this function :  bool 
    <a href="classTCODBsp_1afdc42baf4bfec3759aaf6003b0c6256e.html">TCODBsp::isLeaf() const</a>
  bool TCOD_bsp_is_leaf(TCOD_bsp_t *node)  bsp_is_leaf(node) # bool 
    <a href="classTCODBsp_1afdc42baf4bfec3759aaf6003b0c6256e.html">TCODBsp::isLeaf()</a>
 </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    contains
                    <span class="argsstring"> (int x, int y) const </span>
                </div>
                    <div class="description">
        <div class="para">bsp_read  Check if a cell is inside a node  You can check if a map cell is inside a node.  bool 
    <a href="classTCODBsp_1ab36df4071ad8f93d797d2eb6dab76732.html">TCODBsp::contains(int cx, int cy) const</a>
  bool TCOD_bsp_contains(TCOD_bsp_t *node, int cx, int cy)  bsp_contains(node, cx, cy) # bool TCODBsp::contains(int x, int y)  node In the C version, the node reference.  cx,cy Map cell coordinates. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
    <a href="classTCODBsp.html">TCODBsp</a>
 *
                    </span>
                    findNode
                    <span class="argsstring"> (int x, int y)</span>
                </div>
                    <div class="description">
        <div class="para">bsp_read  Getting the node containing a cell  You can search the tree for the smallest node containing a map cell. If the cell is outside the tree, the function returns NULL :  
    <a href="classTCODBsp.html">TCODBsp</a>
 *TCODBsp::findNode(int cx, int cy)  
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 * TCOD_bsp_find_node(TCOD_bsp_t *node, int cx, int cy)  bsp_find_node(node, cx, cy) # 
    <a href="classTCODBsp.html">TCODBsp</a>
 
    <a href="classTCODBsp_1aea1f327c36198497a74052faf62bba88.html">TCODBsp::findNode(int x, int y)</a>
  node In the C version, the node reference.  cx,cy Map cell coordinates. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    traversePreOrder
                    <span class="argsstring"> (ITCODBspCallback *listener, void *userData)</span>
                </div>
                    <div class="description">
        <div class="para">bsp_traverse  bsp  Traversing the tree  You can scan all the nodes of the tree and have a custom function called back for each node. Each traversal function returns false if the traversal has been interrupted (a callback returned false). Pre-order : the callback is called for the current node, then for the left son, then for the right son. In-order : the callback is called for the left son, then for current node, then for the right son. Post-order : the callback is called for the left son, then for the right son, then for the current node. Level-order : the callback is called for the nodes level by level, from left to right. Inverted level-order : the callback is called in the exact inverse order as Level-order. <models.compound.docTableType object at 0x7fb3deadc780>
</div>
        <div class="para">Pre order</div>
        <div class="para">In order</div>
        <div class="para">Post order</div>
        <div class="para">Level order</div>
        <div class="para">Inverted level<models.compound.docEmptyType object at 0x7fb3deadcb38>
order </div>
        <div class="para"><models.compound.docImageType object at 0x7fb3deadccc0>
</div>
        <div class="para"><models.compound.docImageType object at 0x7fb3deadce10>
</div>
        <div class="para"><models.compound.docImageType object at 0x7fb3deadcf60>
</div>
        <div class="para"><models.compound.docImageType object at 0x7fb3dea130f0>
</div>
        <div class="para"><models.compound.docImageType object at 0x7fb3dea13240>
 </tbody></div>
        <div class="para">class 
    <a href="classITCODBspCallback.html">ITCODBspCallback</a>
 { public : virtual bool visitNode(TCODBsp *node, void *userData) = 0; };</div>
        <div class="para">bool 
    <a href="classTCODBsp_1a781ae46ca99abb56b9e5d0a6bc4113ca.html">TCODBsp::traversePreOrder(ITCODBspCallback *callback, void *userData)</a>
 bool TCODBsp::traverseInOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traversePostOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traverseLevelOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback *callback, void *userData)  typedef bool (*TCOD_bsp_callback_t)(
    <a href="structTCOD__bsp__t.html">TCOD_bsp_t</a>
 *node, void *userData)</div>
        <div class="para">bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)  def bsp_callback(node, userData) : # ...</div>
        <div class="para">bsp_traverse_pre_order(node, callback, userData=0) bsp_traverse_in_order(node, callback, userData=0) bsp_traverse_post_order(node, callback, userData=0) bsp_traverse_level_order(node, callback, userData=0) bsp_traverse_inverted_level_order(node, callback, userData=0) # bool TCODBsp::traversePreOrder(ITCODBspCallback callback) bool TCODBsp::traverseInOrder(ITCODBspCallback callback) bool TCODBsp::traversePostOrder(ITCODBspCallback callback) bool TCODBsp::traverseLevelOrder(ITCODBspCallback callback) bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback callback)  node In the C version, the node reference (generally, the root node).  callback The function to call for each node. It receives the current node and the custom data as parameters If it returns false, the traversal is interrupted.  userData Custom data to pass to the callback.  class MyCallback : public 
    <a href="classITCODBspCallback.html">ITCODBspCallback</a>
 { public : bool visitNode(TCODBsp *node, void *userData) { printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level); return true; } }; myBSP->traversePostOrder(new MyListener(),NULL);  bool my_callback(TCOD_bsp_t *node, void *userData) { printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level); return true; } TCOD_bsp_traverse_post_order(my_bsp,my_callback,NULL);  def my_callback(node, userData) : print "node pos %dx%d size %dx%d level %d"%(node.x,node.y,node.w,node.h,node.level)) return True libtcod.bsp_traverse_post_order(my_bsp,my_callback) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    traverseInOrder
                    <span class="argsstring"> (ITCODBspCallback *listener, void *userData)</span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    traversePostOrder
                    <span class="argsstring"> (ITCODBspCallback *listener, void *userData)</span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    traverseLevelOrder
                    <span class="argsstring"> (ITCODBspCallback *listener, void *userData)</span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    traverseInvertedLevelOrder
                    <span class="argsstring"> (ITCODBspCallback *listener, void *userData)</span>
                </div>
                    <div class="description">
</div>
            </div>
    </div>

            
    <div class="section members">
        <h2>Protected Functions</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    TCODBsp
                    <span class="argsstring"> (TCODBsp *father, bool left)</span>
                </div>
                    <div class="description">
</div>
            </div>
    </div>

    </div>

            </div>
        </body>
    </html>
