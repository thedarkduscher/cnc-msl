#include "Plans/Standards/Own/KickOff/constraints/OwnKickOff1438785376159Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1438785376159) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ProblemDescriptor.h"
#include "MSLWorldModel.h"
#include "engine/model/EntryPoint.h"
#include "engine/RunningPlan.h"
#include "engine/Assignment.h"
#include "engine/model/Plan.h"
#include <Robots.h>
#include <Ball.h>
#include <Game.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:OwnKickOff

    /*
     * Tasks:
     * - EP:1438785376161 : ExecuteStandard (1439997010902)
     * - EP:1438785392109 : ReceiveStandard (1439997023446)
     * - EP:1444834088607 : Defend (1225115406909)
     *
     * States:
     * - PosExec (1438785376160)
     * - PosRecv (1438785501838)
     * - GrabBall (1440675376134)
     * - Pass (1440772305591)
     * - Receive (1440772454611)
     * - Success (1440772500050)
     * - RunFree (1441811642575)
     * - PosDef (1444834163414)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString):
     * Static Variables: []
     * Domain Variables:

     * forall agents in ExecuteStandard let v = [x, y]

     */
    void Constraint1469455112199::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1469455112199) ENABLED START*/

        msl::MSLWorldModel* wm = msl::MSLWorldModel::get();
        auto constraint = autodiff::LTConstraint::TRUE;
        auto util = autodiff::TermBuilder::constant(0);
        auto domainVariables = c->getDomainVars();

        vector < shared_ptr < TVec >> poses;

        vector < shared_ptr < TVec >> executor;

        vector < shared_ptr < geometry::CNPosition >> robotPositions;

        for (int i = 0; i < domainVariables->at(0)->size(); i++)
        {
            c->getDomainRanges()->at(0).at(i).at(0).at(0) = -wm->field->getFieldLength() / 2;
            c->getDomainRanges()->at(0).at(i).at(0).at(1) = wm->field->getFieldLength() / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(0) = -wm->field->getFieldWidth() / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(1) = wm->field->getFieldWidth() / 2;
            robotPositions.push_back(wm->robots->teammates.getTeamMatePosition(c->getAgentsInScope()->at(0)->at(i)));
            auto vec = make_shared < TVec
                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(0)),
                                                           dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(1))});
            poses.push_back(vec);
            executor.push_back(vec);
        }

        // END INITIALIZE VARIABLE CONTAINER

        shared_ptr < geometry::CNPoint2D > ballPose = wm->ball->getAlloBallPosition();
        if (ballPose == nullptr)
        {
            ballPose = make_shared < geometry::CNPoint2D > (0, 0);
        }
        shared_ptr < TVec > tvecBallPose = make_shared < TVec > (initializer_list<double> {ballPose->x, ballPose->y});

        constraint = constraint & msl::MSLConstraintBuilder::applyRules(-1, poses);

        //Just for the case when we use this after "start" has been pressed
        if (wm->game->getSituation() == msl::Situation::Start)
        {
            constraint = constraint
                    & msl::MSLConstraintBuilder::ownPenaltyAreaDistanceExceptionRule(tvecBallPose, poses);
        }

        auto opps = wm->robots->opponents.getOpponentsAlloClustered();
        vector < shared_ptr < TVec >> oppsVecs;
        shared_ptr < geometry::CNPoint2D > nearestOpp = nullptr;
        //default nearest opp

        if (ballPose != nullptr)
            nearestOpp = make_shared < geometry::CNPoint2D > (ballPose->x - 250, ballPose->y);
        double dist = 999999999;

        if (opps != nullptr)
        {
            for (auto opp : *opps)
            {
                oppsVecs.push_back(make_shared < TVec > (initializer_list<double> {opp->x, opp->y}));
            }
        }

        shared_ptr<vector<int>> r1 = rp->getAssignment()->getRobotsWorking(1438785392109);
        shared_ptr < autodiff::TVec > futurePasser = nullptr;
        shared_ptr < geometry::CNPosition > futurePasserPos = nullptr;
        if (r1->size() == 0 || r1 == nullptr)
        {
            cout << "GenricExecute: No Receiver Assigned!?!?!?" << endl;
            futurePasser = make_shared < autodiff::TVec > (initializer_list<double> {0, 0});
            futurePasserPos = make_shared<geometry::CNPosition>();
        }
        else
        {
            for (int id : *r1)
            {
                futurePasserPos = wm->robots->teammates.getTeamMatePosition(id);
                if (futurePasserPos != nullptr)
                {
                    futurePasser = make_shared < autodiff::TVec > (initializer_list<double> {futurePasserPos->x,
                                                                                             futurePasserPos->y});
                }
                else
                {
                    cout << "GenericExecute: No Receiver Position in WM" << endl;
                    futurePasserPos = make_shared<geometry::CNPosition>();
                    futurePasser = make_shared < autodiff::TVec > (initializer_list<double> {0, 0});
                }
                break;
            }

        }

        //avoid teammates
        auto mates = wm->robots->teammates.getTeammatesAlloClustered();
        vector < shared_ptr < autodiff::TVec >> mateVec;
        if (mates != nullptr)
        {
            for (int i = 0; i < mates->size(); i++)
            {
                mateVec.push_back(
                        make_shared < autodiff::TVec > (initializer_list<double> {mates->at(i)->x, mates->at(i)->y}));

            }
        }

        shared_ptr < autodiff::TVec > target = executor.at(0);
//      vector<shared_ptr<autodiff::TVec>> oppsVecs;
        shared_ptr < autodiff::Term > minOppDist = autodiff::TermBuilder::constant(1000000);

        if (oppsVecs.size() > 0)
        {
            for (int i = 0; i < oppsVecs.size(); i++)
            {

                constraint = constraint
                        & ConstraintBuilder::distanceSqr(target, oppsVecs[i])
                                > autodiff::TermBuilder::constant(1500 * 1500); //get away from opps

                minOppDist = make_shared < autodiff::Min
                        > (minOppDist, ConstraintBuilder::distance(target, oppsVecs.at(i)));
            }
        }
        else
        {
            minOppDist = autodiff::TermBuilder::constant(0);
        }

        if (executor.size() > 0)
        {

            //Get Position of future passing robot...
            //future passer should be the receiver from kick off execution because he's going to
            //be the robot with the ball

            constraint = constraint
                    & (ConstraintBuilder::distanceSqr(target, tvecBallPose)
                            > autodiff::TermBuilder::constant(1500 * 1500));

            constraint = constraint & executor.at(0).get()->getX() > autodiff::TermBuilder::constant(500);

            constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OppPenaltyArea, target);
            constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OwnPenaltyArea, target);

            if (mateVec.size() > 0)
            {
                for (int i = 0; i < mateVec.size(); i++)
                {
                    constraint = constraint
                            & ConstraintBuilder::distanceSqr(target, mateVec[i])
                                    > autodiff::TermBuilder::constant(2000 * 2000); //get away from mates
                }
            }

        }

        double targetDist = abs(futurePasserPos->y) + wm->field->getFieldWidth() * 0.5;
        targetDist += 500;

        //optimize distance to opps
        util = util + 100000
                - (make_shared < autodiff::Abs > (targetDist - ConstraintBuilder::distance(target, futurePasser)))
                + minOppDist;
        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));

        /*PROTECTED REGION END*/
    }

// State: PosExec

// State: PosExec

// State: PosRecv

// State: PosRecv

// State: GrabBall

// State: GrabBall

// State: Pass

// State: Pass

// State: Receive

// State: Receive

// State: Success

// State: Success

// State: RunFree

// State: RunFree

// State: PosDef

// State: PosDef

}
