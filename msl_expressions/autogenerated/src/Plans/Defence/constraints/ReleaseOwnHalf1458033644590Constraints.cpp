#include "Plans/Defence/constraints/ReleaseOwnHalf1458033644590Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1458033644590) ENABLED START*/
//Add additional using directives here
#include "MSLFootballField.h"
#include "MSLWorldModel.h"
#include "engine/constraintmodul/ProblemDescriptor.h"
#include "engine/RunningPlan.h"
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "engine/model/AbstractPlan.h"
#include "engine/model/Plan.h"
#include "engine/model/EntryPoint.h"
#include "engine/model/Task.h"
#include "engine/Assignment.h"
#include <container/CNPosition.h>
#include <WhiteBoard.h>
#include <RawSensorData.h>
#include <Ball.h>
#include <Robots.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:ReleaseOwnHalf

    /*
     * Tasks:
     * - EP:1458033660893 : DefaultTask (1225112227903)
     *
     * States:
     * - ReleaseOwnHalf (1458033660892)
     *
     * Vars:
     * - X (1458033962376)
     * - Y (1458033968280)
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString):
     * Static Variables: [X, Y]
     * Domain Variables:

     */
    void Constraint1458033759784::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1458033759784) ENABLED START*/
        msl::MSLWorldModel* wm = msl::MSLWorldModel::get();
        auto util = autodiff::TermBuilder::constant(0);
        auto constraint = autodiff::LTConstraint::TRUE;
        c->getStaticRanges()->at(0).at(0) = -wm->field->getFieldLength() / 2.0 + wm->field->getPenaltyAreaLength();
        c->getStaticRanges()->at(0).at(1) = wm->field->getFieldLength() / 2.0 - wm->field->getPenaltyAreaWidth();
        c->getStaticRanges()->at(1).at(0) = -wm->field->getFieldWidth() / 2.0;
        c->getStaticRanges()->at(1).at(1) = wm->field->getFieldWidth() / 2.0;

        vector < shared_ptr < autodiff::Term >> targetPosVec;
        targetPosVec.push_back(dynamic_pointer_cast < autodiff::Term > (c->getStaticVars()->at(0)));
        targetPosVec.push_back(dynamic_pointer_cast < autodiff::Term > (c->getStaticVars()->at(1)));
        shared_ptr < autodiff::TVec > tMidFieldDefPos = make_shared < autodiff::TVec > (targetPosVec);

        // Get the Attacker Pos
        EntryPoint* attackerEp = nullptr;
        shared_ptr < RunningPlan > cur = rp->getParent().lock();
        while (cur != nullptr)
        {
            if (cur->getPlan()->getName().compare("AttackPlay"))
            {
                for (auto e : ((Plan*)cur->getPlan())->getEntryPoints())
                {
                    if (e.second->getTask()->getName().compare("Attack"))
                    {
                        attackerEp = e.second;
                        break;
                    }
                }
                break;
            }
            cur = cur->getParent().lock();
        }

        if (attackerEp == nullptr)
        {
            cout << "ReleaseOwnHalfConstraints: No Attacker EntryPoint found!" << endl;
            constraint = constraint & ConstraintBuilder::FALSE;
            return;
        }

        cur = rp->getParent().lock();
        shared_ptr<vector<int>> attacker = make_shared<vector<int>>();
        while (cur != nullptr)
        {
            if (((Plan*)cur->getPlan())->getEntryPoints().find(attackerEp->getId())
                    != ((Plan*)cur->getPlan())->getEntryPoints().end())
            {
                attacker = cur->getAssignment()->getRobotsWorking(attackerEp);
                break;
            }
            cur = cur->getParent().lock();
        }

        shared_ptr < geometry::CNPosition > attackerPos = nullptr;
        if (attacker != nullptr)
        {
            for (int mateId : *attacker)
            {
                attackerPos = wm->robots->teammates.getTeamMatePosition(mateId);
                break;
            }
        }

        if (attackerPos == nullptr)
        {
            cout << "ReleaseOwnHalfConstraints: No Attacker Position found!" << endl;
            constraint = constraint & ConstraintBuilder::FALSE;
            return;
        }

        shared_ptr < autodiff::TVec > tAttackerPos = make_shared < autodiff::TVec > (initializer_list<double> {
                attackerPos->x, attackerPos->y});
        constraint = constraint
                & ConstraintBuilder::distanceSqr(tAttackerPos, tMidFieldDefPos)
                        > autodiff::TermBuilder::constant(2000.0 * 2000.0);
        constraint = constraint
                & autodiff::TermBuilder::constant(
                        make_shared < autodiff::Abs > (tMidFieldDefPos->getY() - tAttackerPos->getY())
                                > autodiff::TermBuilder::constant(500.0));

        // min dist away from all obtacles
        auto opps = wm->robots->opponents.getOpponentsAlloClustered(); //GetTrackedOpponents();
        if (opps->size() > 0)
        {
            for (int i = 0; i < opps->size(); i++)
            {
                shared_ptr < autodiff::TVec > tOpp = make_shared < autodiff::TVec
                        > (initializer_list<double> {opps->at(i)->x, opps->at(i)->y});
                constraint = constraint
                        & ConstraintBuilder::distanceSqr(tOpp, tMidFieldDefPos)
                                > autodiff::TermBuilder::constant(700.0 * 700.0);
            }
        }

        auto teammates = wm->robots->teammates.getTeammatesAlloClustered();
        if (teammates->size() > 0)
        {
            for (int i = 0; i < teammates->size(); i++)
            {
                shared_ptr < autodiff::TVec > tMate = make_shared < autodiff::TVec > (initializer_list<double> {
                        teammates->at(i)->x, teammates->at(i)->y});
                constraint = constraint
                        & ConstraintBuilder::distanceSqr(tMate, tMidFieldDefPos)
                                > autodiff::TermBuilder::constant(1500.0 * 1500.0);
            }
        }

        shared_ptr < autodiff::TVec > optP1 = tAttackerPos + make_shared < autodiff::TVec > (initializer_list<double> {
                -400.0, 2000.0});
        shared_ptr < autodiff::TVec > optP2 = tAttackerPos + make_shared < autodiff::TVec > (initializer_list<double> {
                -400.0, -2000.0});

        shared_ptr < autodiff::Term > weightShiftP1 = (1 - make_shared < autodiff::Abs
                > (optP1->getY()) / (wm->field->getFieldWidth() / 2));
        shared_ptr < autodiff::Term > weightShiftP2 = (1 - make_shared < autodiff::Abs
                > (optP2->getY()) / (wm->field->getFieldWidth() / 2));

        shared_ptr < geometry::CNPosition > pos = wm->rawSensorData->getOwnPositionVision();
        if (pos != nullptr)
        {
            shared_ptr < geometry::CNPoint2D > distVec1 = (attackerPos->getPoint() + make_shared < geometry::CNPoint2D
                    > (-400.0, 2000)) - pos;
            shared_ptr < geometry::CNPoint2D > distVec2 = (attackerPos->getPoint() + make_shared < geometry::CNPoint2D
                    > (-400.0, -2000)) - pos;
            if (distVec1->length() > distVec2->length())
            {
                if (attackerPos->y < -500 || (distVec1->length() < 1800.0 && attackerPos->y < 500))
                {
                    util = util
                            + 5
                                    * (1
                                            - ConstraintBuilder::distanceSqr(optP1, tMidFieldDefPos)
                                                    / wm->field->getMaxDistanceSqr()) * weightShiftP1;
                }
                else
                {
                    util = util
                            + 5
                                    * (1
                                            - ConstraintBuilder::distanceSqr(optP2, tMidFieldDefPos)
                                                    / wm->field->getMaxDistanceSqr()) * weightShiftP2;
                }
            }
            else
            {
                if (attackerPos->y > 500 || (distVec2->length() < 1800.0 && attackerPos->y > -500))
                {
                    util = util
                            + 5
                                    * (1
                                            - ConstraintBuilder::distanceSqr(optP2, tMidFieldDefPos)
                                                    / wm->field->getMaxDistanceSqr()) * weightShiftP2;
                }
                else
                {
                    util = util
                            + 5
                                    * (1
                                            - ConstraintBuilder::distanceSqr(optP1, tMidFieldDefPos)
                                                    / wm->field->getMaxDistanceSqr()) * weightShiftP1;
                }
            }

            //avoid teammates
            auto mates = wm->robots->teammates.getTeammatesAlloClustered();
            vector < shared_ptr < autodiff::TVec >> mateVec;
            if (mates != nullptr)
            {
                for (int i = 0; i < mates->size(); i++)
                {
                    mateVec.push_back(
                            make_shared < autodiff::TVec
                                    > (initializer_list<double> {mates->at(i)->x, mates->at(i)->y}));
                    constraint = constraint
                            & ConstraintBuilder::distanceSqr(tMidFieldDefPos, mateVec[i])
                                    > autodiff::TermBuilder::constant(750 * 750); //get away from mates
                }
            }
            //Pass should be at most 2m away from the ball (relevant if we do not have the ball)
            shared_ptr < geometry::CNPoint2D > ballPos = wm->ball->getAlloBallPosition();
            if (ballPos != nullptr
                    && (wm->whiteBoard->getPassMsg() == nullptr
                            || wm->whiteBoard->getPassMsg()->receiverID != wm->getOwnId()))
            {
                shared_ptr < TVec > tvecBallPose = make_shared < TVec
                        > (initializer_list<double> {ballPos->x, ballPos->y});
                constraint = constraint
                        & (ConstraintBuilder::distanceSqr(tMidFieldDefPos, tvecBallPose)
                                > autodiff::TermBuilder::constant(1500 * 1500));
            }

            //add 'lazyness' utility for stability:
            shared_ptr < autodiff::Term > util2 = 1
                    - ConstraintBuilder::distanceSqr(tMidFieldDefPos,
                                                     make_shared < autodiff::TVec > (initializer_list<double> {pos->x,
                                                                                                               pos->y}))
                            / wm->field->getMaxDistanceSqr();
            util = util + util2 * util2;
            c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
            c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));
        }

        /*PROTECTED REGION END*/
    }

// State: ReleaseOwnHalf

// State: ReleaseOwnHalf

}
