
    <!DOCTYPE html>
    <html>
        <head>
            <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro" rel="stylesheet">
            <link rel="stylesheet" href="style.css">
        </head>
        <body>
            <div id="sidebar">
                
    <h3>Namespaces</h3>
    <ul class="namespaces">
        <li ><a href="namespaceaccelMax.html">accelMax</a></li>
        <li ><a href="namespaceAdafruit__GPIO.html">Adafruit_GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1FT232H.html">Adafruit_GPIO::FT232H</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1GPIO.html">Adafruit_GPIO::GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1I2C.html">Adafruit_GPIO::I2C</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1MCP230xx.html">Adafruit_GPIO::MCP230xx</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PCF8574.html">Adafruit_GPIO::PCF8574</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1Platform.html">Adafruit_GPIO::Platform</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PWM.html">Adafruit_GPIO::PWM</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1SPI.html">Adafruit_GPIO::SPI</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master.html">Adafruit_LSM9DS0-master</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0__example.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0_example</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Fuse__LSM9DS0.html">Adafruit_LSM9DS0-master::Fuse_LSM9DS0</a></li>
        <li ><a href="namespacealica.html">alica</a></li>
        <li ><a href="namespacealicaAutogenerated.html">alicaAutogenerated</a></li>
        <li ><a href="namespaceautodiff.html">autodiff</a></li>
        <li ><a href="namespaceBlackLib.html">BlackLib</a></li>
        <li ><a href="namespacecambada.html">cambada</a></li>
        <li ><a href="namespacecambada_1_1geom.html">cambada::geom</a></li>
        <li ><a href="namespacecambada_1_1loc.html">cambada::loc</a></li>
        <li ><a href="namespacecambada_1_1util.html">cambada::util</a></li>
        <li ><a href="namespacecastor.html">castor</a></li>
        <li ><a href="namespaceCNMC__Debug__Client.html">CNMC_Debug_Client</a></li>
        <li ><a href="namespaceCNMC__Debug__Client_1_1Properties.html">CNMC_Debug_Client::Properties</a></li>
        <li ><a href="namespacecompassCalib.html">compassCalib</a></li>
        <li ><a href="namespacecomplete.html">complete</a></li>
        <li ><a href="namespacedoxy2swig.html">doxy2swig</a></li>
        <li ><a href="namespaceez__setup.html">ez_setup</a></li>
        <li ><a href="namespaceFtdi.html">Ftdi</a></li>
        <li ><a href="namespacegazebo__msgs.html">gazebo_msgs</a></li>
        <li ><a href="namespacegeometry.html">geometry</a></li>
        <li ><a href="namespacegeometry__msgs.html">geometry_msgs</a></li>
        <li ><a href="namespacei2c-test.html">i2c-test</a></li>
        <li ><a href="namespaceList.html">List</a></li>
        <li ><a href="namespacelsm-test.html">lsm-test</a></li>
        <li ><a href="namespacemsl.html">msl</a></li>
        <li ><a href="namespacemsl__actuator__msgs.html">msl_actuator_msgs</a></li>
        <li ><a href="namespacemsl__helper__msgs.html">msl_helper_msgs</a></li>
        <li ><a href="namespacemsl__joystick.html">msl_joystick</a></li>
        <li ><a href="namespacemsl__msgs.html">msl_msgs</a></li>
        <li ><a href="namespacemsl__ptgrey__camera.html">msl_ptgrey_camera</a></li>
        <li ><a href="namespacemsl__refbox.html">msl_refbox</a></li>
        <li ><a href="namespacemsl__sensor__msgs.html">msl_sensor_msgs</a></li>
        <li ><a href="namespacemulticast.html">multicast</a></li>
        <li ><a href="namespacesensor__msgs.html">sensor_msgs</a></li>
        <li ><a href="namespacesetup.html">setup</a></li>
        <li ><a href="namespacesimple.html">simple</a></li>
        <li ><a href="namespacesplines.html">splines</a></li>
        <li ><a href="namespacestd.html">std</a></li>
        <li ><a href="namespacestd__msgs.html">std_msgs</a></li>
        <li ><a href="namespacesupplementary.html">supplementary</a></li>
        <li ><a href="namespaceSystem.html">System</a></li>
        <li ><a href="namespaceSystem_1_1Collections_1_1Generic.html">System::Collections::Generic</a></li>
        <li ><a href="namespaceSystem_1_1ComponentModel.html">System::ComponentModel</a></li>
        <li ><a href="namespaceSystem_1_1Data.html">System::Data</a></li>
        <li ><a href="namespaceSystem_1_1Drawing.html">System::Drawing</a></li>
        <li ><a href="namespaceSystem_1_1IO_1_1Ports.html">System::IO::Ports</a></li>
        <li ><a href="namespaceSystem_1_1Linq.html">System::Linq</a></li>
        <li ><a href="namespaceSystem_1_1Reflection.html">System::Reflection</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1CompilerServices.html">System::Runtime::CompilerServices</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1InteropServices.html">System::Runtime::InteropServices</a></li>
        <li ><a href="namespaceSystem_1_1Text.html">System::Text</a></li>
        <li ><a href="namespaceSystem_1_1Threading.html">System::Threading</a></li>
        <li ><a href="namespaceSystem_1_1Windows_1_1Forms.html">System::Windows::Forms</a></li>
        <li ><a href="namespacetests.html">tests</a></li>
        <li ><a href="namespacetests_1_1MockGPIO.html">tests::MockGPIO</a></li>
        <li ><a href="namespacetests_1_1test__GPIO.html">tests::test_GPIO</a></li>
        <li ><a href="namespacetests_1_1test__I2C.html">tests::test_I2C</a></li>
        <li ><a href="namespacetests_1_1test__Platform.html">tests::test_Platform</a></li>
        <li ><a href="namespacetests_1_1test__PWM.html">tests::test_PWM</a></li>
        <li ><a href="namespacetests_1_1test__SPI.html">tests::test_SPI</a></li>
        <li ><a href="namespacetinyxml2.html">tinyxml2</a></li>
        <li ><a href="namespacexmlpp.html">xmlpp</a></li>
    </ul>

            </div>
            <div id="content">
                
    <div class="compound class">
        <h1 class="title">Class <span class="accent">TCODPath</span></h1>
            <div class="description">
        <div class="para">path  Path finding  Roguelike toolkits  This toolkit allows to easily calculate the optimal path between two points in your dungeon by using either the <models.compound.docURLLink object at 0x7fb3dead4710> or <models.compound.docURLLink object at 0x7fb3dead46d8>. Please note that the paths generated with the two algorithms may differ slightly. Due to how they're implemented, A* will usually prefer diagonal moves over orthogonal, while Dijkstra will have the opposite preference. In other words, paths from point X to point Y will look like this: <models.compound.docMarkupType object at 0x7fb3dead4828> </div>
</div>
            
    <div class="section members">
        <h2>Protected Members</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        TCOD_path_t
                    </span>
                    data
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        struct 
    <a href="structTCODPath_1_1WrapperData.html">TCODPath::WrapperData</a>

                    </span>
                    cppData
                    <span class="argsstring"> </span>
                </div>
                    <div class="description">
</div>
            </div>
    </div>

            
    <div class="section members">
        <h2>Public Functions</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    TCODPath
                    <span class="argsstring"> (const TCODMap *map, float diagonalCost=1.41f)</span>
                </div>
                    <div class="description">
        <div class="para">path_init  path  Creating a path  Allocating a pathfinder from a map  First, you have to allocate a path using a map from <models.compound.docURLLink object at 0x7fb3de8304e0>.  
    <a href="classTCODPath_1ae05e2f3d2e93e399274f6e05d5ebd841.html">TCODPath::TCODPath</a>
(const 
    <a href="classTCODMap.html">TCODMap</a>
 *map, float diagonalCost=1.41f) TCODDijkstra::TCODDijkstra(const 
    <a href="classTCODMap.html">TCODMap</a>
 *map, float diagonalCost=1.41f)  TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost) TCOD_dijkstra_t TCOD_dijkstra_new(TCOD_map_t map, float diagonalCost)  path_new_using_map(map, diagonalCost=1.41) dijkstra_new(map, diagonalCost=1.41) # 
    <a href="classTCODPath.html">TCODPath(TCODMap map, float diagonalCost)</a>
 
    <a href="classTCODPath.html">TCODPath(TCODMap map)</a>
 
    <a href="classTCODDijkstra.html">TCODDijkstra(TCODMap map, float diagonalCost)</a>
 
    <a href="classTCODDijkstra.html">TCODDijkstra(TCODMap map)</a>
  map The map. The path finder will use the 'walkable' property of the cells to find a path.  diagonalCost Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f). It you want the same cost for all movements, use 1.0f. If you don't want the path finder to use diagonal movements, use 0.0f.  A* : 
    <a href="classTCODMap.html">TCODMap</a>
 *myMap = new 
    <a href="classTCODMap.html">TCODMap(50,50)</a>
; 
    <a href="classTCODPath.html">TCODPath</a>
 *path = new 
    <a href="classTCODPath.html">TCODPath(myMap)</a>
; // allocate the path Dijkstra: 
    <a href="classTCODMap.html">TCODMap</a>
 *myMap = new 
    <a href="classTCODMap.html">TCODMap(50,50)</a>
; 
    <a href="classTCODDijkstra.html">TCODDijkstra</a>
 *dijkstra = new 
    <a href="classTCODDijkstra.html">TCODDijkstra(myMap)</a>
; // allocate the path  A* : TCOD_map_t my_map=TCOD_map_new(50,50,true); TCOD_path_t path = TCOD_path_new_using_map(my_map,1.41f); Dijkstra : TCOD_map_t my_map=TCOD_map_new(50,50,true); TCOD_dijkstra_t dijk = TCOD_dijkstra_new(my_map,1.41f);  <models.compound.docHeadingType object at 0x7fb3de910d30>
</div>
        <div class="para">my_map=libtcod.map_new(50,50,True) path = libtcod.path_new_using_map(my_map) <models.compound.docHeadingType object at 0x7fb3de910b38>
</div>
        <div class="para">my_map=libtcod.map_new(50,50,True) dijk = libtcod.dijkstra_new(my_map) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    TCODPath
                    <span class="argsstring"> (int width, int height, const ITCODPathCallback *listener, void *userData, float diagonalCost=1.41f)</span>
                </div>
                    <div class="description">
        <div class="para">path_init  Allocating a pathfinder using a callback  Since the walkable status of a cell may depend on a lot of parameters (the creature type, the weather, the terrain type...), you can also create a path by providing a function rather than relying on a 
    <a href="classTCODMap.html">TCODMap</a>
.  Callback : class 
    <a href="classITCODPathCallback.html">ITCODPathCallback</a>
 { public: virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void <em>userData ) const = 0; }; A constructor: 
    <a href="classTCODPath_1ae05e2f3d2e93e399274f6e05d5ebd841.html">TCODPath::TCODPath</a>
(int width, int height, const 
    <a href="classITCODPathCallback.html">ITCODPathCallback</a>
 *callback, void *userData, float diagonalCost=1.41f) Dijkstra constructor TCODDijkstra::TCODDijkstra(int width, int height, const 
    <a href="classITCODPathCallback.html">ITCODPathCallback</a>
 *callback, void *userData, float diagonalCost=1.41f)  typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data ) TCOD_path_t TCOD_path_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost) TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)  def path_func(xFrom,yFrom,xTo,yTo,userData) : ... path_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41) dijkstra_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41) # 
    <a href="classTCODPath.html">TCODPath(int width, int height, ITCODPathCallback listener, float diagonalCost)</a>
 
    <a href="classTCODPath.html">TCODPath(int width, int height, ITCODPathCallback listener)</a>
 
    <a href="classTCODDijkstra.html">TCODDijkstra(int width, int height, ITCODPathCallback listener, float diagonalCost)</a>
 
    <a href="classTCODDijkstra.html">TCODDijkstra(int width, int height, ITCODPathCallback listener)</a>
  width,height The size of the map (in map cells).  callback A custom function that must return the walk cost from coordinates xFrom,yFrom to coordinates xTo,yTo. The cost must be > 0.0f if the cell xTo,yTo is walkable. It must be equal to 0.0f if it's not. You must not take additional cost due to diagonal movements into account as it's already done by the pathfinder.  userData Custom data that will be passed to the function.  diagonalCost Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f). It you want the same cost for all movements, use 1.0f. If you don't want the path finder to use diagonal movements, use 0.0f.  class MyCallback : public 
    <a href="classITCODPathCallback.html">ITCODPathCallback</a>
 { public : float getWalkCost(int xFrom, int yFrom, int xTo, int yTo, void *userData ) const { ... } }; 
    <a href="classTCODPath.html">TCODPath</a>
 *path = new 
    <a href="classTCODPath.html">TCODPath(50,50,new MyCallback(),NULL)</a>
; // allocate the path 
    <a href="classTCODDijkstra.html">TCODDijkstra</a>
 *dijkstra = new 
    <a href="classTCODDijkstra.html">TCODDijkstra(50,50,new MyCallback(),NULL)</a>
; // allocate Dijkstra  float my_func(int xFrom, int yFrom, int xTo, int yTo, void *user_data) { ... } TCOD_path_t path = TCOD_path_new_using_function(50,50,my_func,NULL,1.41f); TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new_using_function(50,50,my_func,NULL,1.41f);  def my_func(xFrom, yFrom, xTo, yTo, user_data) : <models.compound.docHeadingType object at 0x7fb3de59ab00>
</div>
        <div class="para">return 1.0 path = libtcod.path_new_using_function(50,50,my_func) dijkstra = libtcod.dijkstra_new_using_function(50,50,my_func) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    ~TCODPath
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
        <div class="para">path_init  Destroying a path  To release the resources used by a path, destroy it with :  
    <a href="classTCODPath_1a5fc271e34064a27685ee5b491a7a7ab7.html">TCODPath::~TCODPath()</a>
 TCODDijkstra::~TCODDijkstra()  void TCOD_path_delete(TCOD_path_t path) void TCOD_dijkstra_delete(TCOD_dijkstra_t dijkstra)  path_delete(path) dijkstra_delete(dijkstra) # void TCODPath::Dispose() void TCODDijkstra::Dispose()  path In the C version, the path handler returned by one of the TCOD_path_new_* function.  dijkstra In the C version, the path handler returned by one of the TCOD_dijkstra_new* function.  
    <a href="classTCODPath.html">TCODPath</a>
 *path = new 
    <a href="classTCODPath.html">TCODPath(myMap)</a>
; // allocate the path use the path... delete path; // destroy the path</div>
        <div class="para">
    <a href="classTCODDijkstra.html">TCODDijkstra</a>
 *dijkstra = new 
    <a href="classTCODDijkstra.html">TCODDijkstra(myMap)</a>
; // allocate the path use the path... delete dijkstra; // destroy the path  TCOD_path_t path = TCOD_path_new_using_map(my_map); use the path ... TCOD_path_delete(path);</div>
        <div class="para">TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map); use the path ... TCOD_dijkstra_delete(dijkstra);  path = libtcod.path_new_using_map(my_map) <models.compound.docHeadingType object at 0x7fb3de85cf60>
</div>
        <div class="para">libtcod.path_delete(path)</div>
        <div class="para">dijkstra = libtcod.dijkstra_new(my_map) <models.compound.docHeadingType object at 0x7fb3de832780>
</div>
        <div class="para">libtcod.dijkstra_delete(dijkstra) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    compute
                    <span class="argsstring"> (int ox, int oy, int dx, int dy)</span>
                </div>
                    <div class="description">
        <div class="para">path_compute  path  Computing the path  Computing an A* path  Once you created a 
    <a href="classTCODPath.html">TCODPath</a>
 object, you can compute the path between two points:  bool 
    <a href="classTCODPath_1a42f824082c58ca1830fdfca2b72ce3b2.html">TCODPath::compute(int ox, int oy, int dx, int dy)</a>
  bool TCOD_path_compute(TCOD_path_t path, int ox,int oy, int dx, int dy)  path_compute(path, ox, oy, dx, dy) # void 
    <a href="classTCODPath_1a42f824082c58ca1830fdfca2b72ce3b2.html">TCODPath::compute(int ox, int oy, int dx, int dy)</a>
  path In the C version, the path handler returned by a creation function.  ox,oy Coordinates of the origin of the path.  dx,dy Coordinates of the destination of the path. Both points should be inside the map, and at a walkable position. The function returns false if there is no possible path.  
    <a href="classTCODMap.html">TCODMap</a>
 *myMap = new 
    <a href="classTCODMap.html">TCODMap(50,50)</a>
; 
    <a href="classTCODPath.html">TCODPath</a>
 *path = new 
    <a href="classTCODPath.html">TCODPath(myMap)</a>
; // allocate the path path->compute(5,5,25,25); // calculate path from 5,5 to 25,25  TCOD_map_t my_map=TCOD_map_new(50,50); TCOD_path_t path = TCOD_path_new_using_map(my_map); TCOD_path_compute(path,5,5,25,25);  my_map=libtcod.map_new(50,50) path = libtcod.path_new_using_map(my_map) libtcod.path_compute(path,5,5,25,25) </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    reverse
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
        <div class="para">path_compute  Reversing a path  Once you computed a path, you can exchange origin and destination :  void 
    <a href="classTCODPath_1a93b1805f9fb6aeeb152b6bec1fd9ff8a.html">TCODPath::reverse()</a>
 void TCODDijkstra::reverse()  void TCOD_path_reverse(TCOD_path_t path) void TCOD_dijkstra_reverse(TCOD_dijkstra_t dijkstra)  path_reverse(path) dijkstra_reverse(dijkstra) # void 
    <a href="classTCODPath_1a93b1805f9fb6aeeb152b6bec1fd9ff8a.html">TCODPath::reverse()</a>
 void TCODDijkstra::reverse()  path In the C version, the path handler returned by a creation function.  
    <a href="classTCODMap.html">TCODMap</a>
 *myMap = new 
    <a href="classTCODMap.html">TCODMap(50,50)</a>
; 
    <a href="classTCODPath.html">TCODPath</a>
 *path = new 
    <a href="classTCODPath.html">TCODPath(myMap)</a>
; // allocate the path path->compute(5,5,25,25); // calculate path from 5,5 to 25,25 path->
    <a href="classTCODPath_1a93b1805f9fb6aeeb152b6bec1fd9ff8a.html">reverse()</a>
; // now the path goes from 25,25 to 5,5  TCOD_map_t my_map=TCOD_map_new(50,50); TCOD_path_t path = TCOD_path_new_using_map(my_map); TCOD_path_compute(path,5,5,25,25); // calculate path from 5,5 to 25,25 TCOD_path_reverse(path); // now the path goes from 25,25 to 5,5  my_map=libtcod.map_new(50,50) path = libtcod.path_new_using_map(my_map) libtcod.path_compute(path,5,5,25,25) # calculate path from 5,5 to 25,25 libtcod.path_reverse(path) # now the path goes from 25,25 to 5,5 </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    getOrigin
                    <span class="argsstring"> (int *x, int *y) const </span>
                </div>
                    <div class="description">
        <div class="para">path_read  Reading path information  path  Once the path has been computed, you can get information about it using of one those functions.  Getting the path origin and destination  You can read the current origin and destination cells with getOrigin/getDestination. Note that when you walk the path, the origin changes at each step.  void 
    <a href="classTCODPath_1a0f2d9e680aa5a8acbdc47ca4ff527c76.html">TCODPath::getOrigin(int *x,int *y) const</a>
 void TCODPath::getDestination(int *x,int *y) const  void TCOD_path_get_origin(TCOD_path_t path, int *x, int *y) void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y)  path_get_origin(path) # returns x,y path_get_destination(path) # returns x,y # void TCODPath::getOrigin(out int x, out int y) void TCODPath::getDestination(out int x, out int y)  path In the C version, the path handler returned by a creation function.  x,y The function returns the cell coordinates in these variables </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    getDestination
                    <span class="argsstring"> (int *x, int *y) const </span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        int
                    </span>
                    size
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
        <div class="para">path_read  Getting the path length  You can get the number of steps needed to reach destination :  int 
    <a href="classTCODPath_1aba4695feadda4a61d564b8148eddceb0.html">TCODPath::size() const</a>
 int TCODDijkstra::size() const  int TCOD_path_size(TCOD_path_t path) int TCOD_dijkstra_size(TCOD_dijkstra_t dijkstra)  path_size(path) dijkstra_size(dijkstra) # int 
    <a href="classTCODPath_1aba4695feadda4a61d564b8148eddceb0.html">TCODPath::size()</a>
 int TCODDijkstra::size()  path, dijkstra In the C version, the path handler returned by a creation function. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    get
                    <span class="argsstring"> (int index, int *x, int *y) const </span>
                </div>
                    <div class="description">
        <div class="para">path_read  Read the path cells' coordinates  You can get the coordinates of each point along the path :  void 
    <a href="classTCODPath_1af25795a08ef80fd99f548e46bbf16695.html">TCODPath::get(int index, int *x, int *y) const</a>
 void TCODDijkstra::get(int index, int *x, int *y) const  void TCOD_path_get(TCOD_path_t path, int index, int *x, int *y) void TCOD_dijkstra_get(TCOD_dijkstra_t dijkstra, int index, int *x, int *y)  path_get(path, index) # returns x,y dijkstra_get(dijkstra, index) # returns x,y # int 
    <a href="classTCODPath_1aba4695feadda4a61d564b8148eddceb0.html">TCODPath::size()</a>
 int TCODDijkstra::size()  path, dijkstra In the C version, the path handler returned by a creation function.  index Step number. 0 <= index < path size  x,y Address of the variables receiving the coordinates of the point.  for (int i=0; i < path->
    <a href="classTCODPath_1aba4695feadda4a61d564b8148eddceb0.html">size()</a>
; i++ ) { int x,y; path->get(i,&x,&y); printf ("Astar coord : %d %d\n", x,y ); } for (int i=0; i < dijkstra->
    <a href="classTCODPath_1aba4695feadda4a61d564b8148eddceb0.html">size()</a>
; i++ ) { int x,y; dijkstra->get(i,&x,&y); printf ("Dijkstra coord : %d %d\n", x,y ); }  int i; for (i=0; i < TCOD_path_size(path); i++ ) { int x,y; TCOD_path_get(path,i,&x,&y); printf ("Astar coord : %d %d\n", x,y ); } for (i=0; i < TCOD_dijkstra_size(dijkstra); i++ ) { int x,y; TCOD_dijkstra_get(dijkstra,i,&x,&y); printf ("Dijsktra coord : %d %d\n", x,y ); }  for i in range (libtcod.path_size(path)) : x,y=libtcod.path_get(path,i) print 'Astar coord : ',x,y for i in range (libtcod.dijkstra_size(dijkstra)) : x,y=libtcod.dijkstra_get(dijkstra,i) print 'Dijkstra coord : ',x,y </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    isEmpty
                    <span class="argsstring"> () const </span>
                </div>
                    <div class="description">
        <div class="para">path_read  Checking if the path is empty  If you want a creature to follow the path, a more convenient way is to walk the path : You know when you reached destination when the path is empty :  bool 
    <a href="classTCODPath_1a2c739bdbe72d3b9d672baf84a91dcb21.html">TCODPath::isEmpty() const</a>
 bool TCODDijkstra::isEmpty() const  bool TCOD_path_is_empty(TCOD_path_t path) bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t dijkstra)  path_is_empty(path) dijkstra_is_empty(dijkstra) # bool 
    <a href="classTCODPath_1a2c739bdbe72d3b9d672baf84a91dcb21.html">TCODPath::isEmpty()</a>
 bool TCODDijkstra::isEmpty()  path, dijkstra In the C version, the path handler returned by a creation function. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    walk
                    <span class="argsstring"> (int *x, int *y, bool recalculateWhenNeeded)</span>
                </div>
                    <div class="description">
        <div class="para">path_read  Walking the path  You can walk the path and go to the next step with : Note that walking the path consume one step (and decrease the path size by one). The function returns false if recalculateWhenNeeded is false and the next cell on the path is no longer walkable, or if recalculateWhenNeeded is true, the next cell on the path is no longer walkable and no other path has been found. Also note that recalculateWhenNeeded only applies to A*.  bool 
    <a href="classTCODPath_1aad293b06a14a7e1c14a59fe19c3a946b.html">TCODPath::walk(int *x, int *y, bool recalculateWhenNeeded)</a>
 bool TCODDijkstra::walk(int *x, int *y)  bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed) bool TCOD_dijkstra_walk(TCOD_dijkstra_t dijkstra, int *x, int *y)  path_walk(TCOD_path_t path, recalculate_when_needed) # returns x,y or None,None if no path dijkstra_walk(TCOD_dijkstra_t dijkstra) # bool TCODPath::walk(ref int x, ref int y, bool recalculateWhenNeeded) bool TCODDijkstra::walk(ref int x, ref int y)  path, dijkstra In the C version, the path handler returned by a creation function.  x,y Address of the variables receiving the coordinates of the next point.  recalculateWhenNeeded If the next point is no longer walkable (another creature may be in the way), recalculate a new path and walk it.  while (! path->
    <a href="classTCODPath_1a2c739bdbe72d3b9d672baf84a91dcb21.html">isEmpty()</a>
) { int x,y; if (path->walk(&x,&y,true)) { printf ("Astar coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } } while (! dijkstra->
    <a href="classTCODPath_1a2c739bdbe72d3b9d672baf84a91dcb21.html">isEmpty()</a>
) { int x,y; if (dijkstra->walk(&x,&y)) { printf ("Dijkstra coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } }  while (! TCOD_path_is_empty(path)) { int x,y; if (TCOD_path_walk(path,&x,&y,true)) { printf ("Astar coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } } while (! TCOD_dijkstra_is_empty(dijkstra)) { int x,y; if (TCOD_dijkstra_walk(dijkstra,&x,&y)) { printf ("Dijkstra coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } }  while not libtcod.path_is_empty(path)) : x,y=libtcod.path_walk(path,True) if not x is None : print 'Astar coord: ',x,y else : print "I'm stuck!" break while not libtcod.dijkstra_is_empty(dijkstra)) : x,y=libtcod.dijkstra_walk(dijkstra,True) if not x is None : print 'Dijkstra coord: ',x,y else : print "I'm stuck!" break </div>
</div>
            </div>
    </div>

            
    <div class="section members">
        <h2>Friends</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        friend float
                    </span>
                    TCOD_path_func
                    <span class="argsstring"> (int xFrom, int yFrom, int xTo, int yTo, void *data)</span>
                </div>
                    <div class="description">
</div>
            </div>
    </div>

    </div>

            </div>
        </body>
    </html>
