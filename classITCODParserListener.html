
    <!DOCTYPE html>
    <html>
        <head>
            <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro" rel="stylesheet">
            <link rel="stylesheet" href="style.css">
        </head>
        <body>
            <div id="sidebar">
                
    <h3>Namespaces</h3>
    <ul class="namespaces">
        <li ><a href="namespaceaccelMax.html">accelMax</a></li>
        <li ><a href="namespaceAdafruit__GPIO.html">Adafruit_GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1FT232H.html">Adafruit_GPIO::FT232H</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1GPIO.html">Adafruit_GPIO::GPIO</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1I2C.html">Adafruit_GPIO::I2C</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1MCP230xx.html">Adafruit_GPIO::MCP230xx</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PCF8574.html">Adafruit_GPIO::PCF8574</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1Platform.html">Adafruit_GPIO::Platform</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1PWM.html">Adafruit_GPIO::PWM</a></li>
        <li ><a href="namespaceAdafruit__GPIO_1_1SPI.html">Adafruit_GPIO::SPI</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master.html">Adafruit_LSM9DS0-master</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Adafruit__LSM9DS0__example.html">Adafruit_LSM9DS0-master::Adafruit_LSM9DS0_example</a></li>
        <li ><a href="namespaceAdafruit__LSM9DS0-master_1_1Fuse__LSM9DS0.html">Adafruit_LSM9DS0-master::Fuse_LSM9DS0</a></li>
        <li ><a href="namespacealica.html">alica</a></li>
        <li ><a href="namespacealicaAutogenerated.html">alicaAutogenerated</a></li>
        <li ><a href="namespaceautodiff.html">autodiff</a></li>
        <li ><a href="namespaceBlackLib.html">BlackLib</a></li>
        <li ><a href="namespacecambada.html">cambada</a></li>
        <li ><a href="namespacecambada_1_1geom.html">cambada::geom</a></li>
        <li ><a href="namespacecambada_1_1loc.html">cambada::loc</a></li>
        <li ><a href="namespacecambada_1_1util.html">cambada::util</a></li>
        <li ><a href="namespacecastor.html">castor</a></li>
        <li ><a href="namespaceCNMC__Debug__Client.html">CNMC_Debug_Client</a></li>
        <li ><a href="namespaceCNMC__Debug__Client_1_1Properties.html">CNMC_Debug_Client::Properties</a></li>
        <li ><a href="namespacecompassCalib.html">compassCalib</a></li>
        <li ><a href="namespacecomplete.html">complete</a></li>
        <li ><a href="namespacedoxy2swig.html">doxy2swig</a></li>
        <li ><a href="namespaceez__setup.html">ez_setup</a></li>
        <li ><a href="namespaceFtdi.html">Ftdi</a></li>
        <li ><a href="namespacegazebo__msgs.html">gazebo_msgs</a></li>
        <li ><a href="namespacegeometry.html">geometry</a></li>
        <li ><a href="namespacegeometry__msgs.html">geometry_msgs</a></li>
        <li ><a href="namespacei2c-test.html">i2c-test</a></li>
        <li ><a href="namespaceList.html">List</a></li>
        <li ><a href="namespacelsm-test.html">lsm-test</a></li>
        <li ><a href="namespacemsl.html">msl</a></li>
        <li ><a href="namespacemsl__actuator__msgs.html">msl_actuator_msgs</a></li>
        <li ><a href="namespacemsl__helper__msgs.html">msl_helper_msgs</a></li>
        <li ><a href="namespacemsl__joystick.html">msl_joystick</a></li>
        <li ><a href="namespacemsl__msgs.html">msl_msgs</a></li>
        <li ><a href="namespacemsl__ptgrey__camera.html">msl_ptgrey_camera</a></li>
        <li ><a href="namespacemsl__refbox.html">msl_refbox</a></li>
        <li ><a href="namespacemsl__sensor__msgs.html">msl_sensor_msgs</a></li>
        <li ><a href="namespacemulticast.html">multicast</a></li>
        <li ><a href="namespacesensor__msgs.html">sensor_msgs</a></li>
        <li ><a href="namespacesetup.html">setup</a></li>
        <li ><a href="namespacesimple.html">simple</a></li>
        <li ><a href="namespacesplines.html">splines</a></li>
        <li ><a href="namespacestd.html">std</a></li>
        <li ><a href="namespacestd__msgs.html">std_msgs</a></li>
        <li ><a href="namespacesupplementary.html">supplementary</a></li>
        <li ><a href="namespaceSystem.html">System</a></li>
        <li ><a href="namespaceSystem_1_1Collections_1_1Generic.html">System::Collections::Generic</a></li>
        <li ><a href="namespaceSystem_1_1ComponentModel.html">System::ComponentModel</a></li>
        <li ><a href="namespaceSystem_1_1Data.html">System::Data</a></li>
        <li ><a href="namespaceSystem_1_1Drawing.html">System::Drawing</a></li>
        <li ><a href="namespaceSystem_1_1IO_1_1Ports.html">System::IO::Ports</a></li>
        <li ><a href="namespaceSystem_1_1Linq.html">System::Linq</a></li>
        <li ><a href="namespaceSystem_1_1Reflection.html">System::Reflection</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1CompilerServices.html">System::Runtime::CompilerServices</a></li>
        <li ><a href="namespaceSystem_1_1Runtime_1_1InteropServices.html">System::Runtime::InteropServices</a></li>
        <li ><a href="namespaceSystem_1_1Text.html">System::Text</a></li>
        <li ><a href="namespaceSystem_1_1Threading.html">System::Threading</a></li>
        <li ><a href="namespaceSystem_1_1Windows_1_1Forms.html">System::Windows::Forms</a></li>
        <li ><a href="namespacetests.html">tests</a></li>
        <li ><a href="namespacetests_1_1MockGPIO.html">tests::MockGPIO</a></li>
        <li ><a href="namespacetests_1_1test__GPIO.html">tests::test_GPIO</a></li>
        <li ><a href="namespacetests_1_1test__I2C.html">tests::test_I2C</a></li>
        <li ><a href="namespacetests_1_1test__Platform.html">tests::test_Platform</a></li>
        <li ><a href="namespacetests_1_1test__PWM.html">tests::test_PWM</a></li>
        <li ><a href="namespacetests_1_1test__SPI.html">tests::test_SPI</a></li>
        <li ><a href="namespacetinyxml2.html">tinyxml2</a></li>
        <li ><a href="namespacexmlpp.html">xmlpp</a></li>
    </ul>

            </div>
            <div id="content">
                
    <div class="compound class">
        <h1 class="title">Class <span class="accent">ITCODParserListener</span></h1>
            <div class="description">
        <div class="para">parser_run  Creating a listener  For basic config files, you don't have to write a listener. Instead, use the default listener. The parser uses a SAX-like approach during the parsing of the file. This means that the whole file is not stored in memory in a tree structure. Instead, it works like a stream parser and raises events. Each event has an associated callback that is provided by a listener :  class 
    <a href="classITCODParserListener.html">ITCODParserListener</a>
 { public : virtual bool 
    <a href="classITCODParserListener_1aa1f698a183acaa15a38614b0221f3be9.html">parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a>
=0; virtual bool 
    <a href="classITCODParserListener_1af974dd420ac692997810a770e95a647c.html">parserFlag(TCODParser *parser,const char *name)</a>
=0; virtual bool 
    <a href="classITCODParserListener_1a774fd145d75d15179b50539138ec2073.html">parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)</a>
=0; virtual bool 
    <a href="classITCODParserListener_1a346a06c2e438958bf8be5a4cb5c2a770.html">parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)</a>
=0; virtual void 
    <a href="classITCODParserListener_1ad81eca4f32c9411d5b82405f261f9c95.html">error(const char *msg)</a>
 = 0; };  typedef struct { bool (*new_struct)(TCOD_parser_struct_t str,const char *name); bool (*new_flag)(const char *name); bool (*new_property)(const char *name, TCOD_value_type_t type, 
    <a href="unionTCOD__value__t.html">TCOD_value_t</a>
 value); bool (*end_struct)(TCOD_parser_struct_t str, const char *name); void (*error)(const char *msg); } 
    <a href="structTCOD__parser__listener__t.html">TCOD_parser_listener_t</a>
;  class ParserListener : def new_struct(str,name) : ... def new_flag(name) : ... def new_property(name,type,value) : ... def end_struct(self, struct, name) : ... def error(msg) : ...  parser_run  Before running the parser, you have to build a listener :  class MyListener : public 
    <a href="classITCODParserListener.html">ITCODParserListener</a>
 { bool 
    <a href="classITCODParserListener_1aa1f698a183acaa15a38614b0221f3be9.html">parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a>
 { printf ("new structure type '%s' with name '%s'\n",str->getname(),name ? name : "NULL"); return true; } bool 
    <a href="classITCODParserListener_1af974dd420ac692997810a770e95a647c.html">parserFlag(TCODParser *parser,const char *name)</a>
 { printf ("found new flag '%s'\n",name); return true; } bool 
    <a href="classITCODParserListener_1a774fd145d75d15179b50539138ec2073.html">parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)</a>
 { printf ("found new property '%s'\n",name); return true; } bool 
    <a href="classITCODParserListener_1a346a06c2e438958bf8be5a4cb5c2a770.html">parserEndStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a>
 { printf ("end of structure type '%s'\n",name); return true; } void error(char *msg) { fprintf(stderr,msg); exit(1); } };  bool my_parser_new_struct(TCOD_parser_struct_t str, const char *name) { printf ("new structure type '%s' with name '%s'\n",TCOD_struct_get_name(str),name ? name : "NULL"); return true; } bool my_parser_flag(const char *name) { printf ("found new flag '%s'\n",name); return true; } bool my_parser_property(const char *name, TCOD_value_type_t type, TCOD_value_t value) { printf ("found new property '%s'\n",name); return true; } bool my_parser_end_struct(TCOD_parser_struct_t str, const char *name) { printf ("end of structure type '%s'\n",name); return true; } void my_parser_error(const char *msg) { fprintf(stderr,msg); exit(1); } 
    <a href="structTCOD__parser__listener__t.html">TCOD_parser_listener_t</a>
 my_listener = { my_parser_new_struct, my_parser_flag, my_parser_property, my_parser_end_struct, my_parser_error };  class MyListener: def new_struct(self, struct, name): print 'new structure type', libtcod.struct_get_name(struct), ' named ', name return True def new_flag(self, name): print 'new flag named ', name return True def new_property(self,name, typ, value): type_names = ['NONE', 'BOOL', 'CHAR', 'INT', 'FLOAT', 'STRING', 'COLOR', 'DICE'] if typ == libtcod.TYPE_COLOR : print 'new property named ', name,' type ',type_names[typ], ' value ', value.r, value.g, value.b elif typ == libtcod.TYPE_DICE : print 'new property named ', name,' type ',type_names[typ], ' value ', value.nb_rolls, value.nb_faces, value.multiplier, value.addsub else: print 'new property named ', name,' type ',type_names[typ], ' value ', value return True def end_struct(self, struct, name): print 'end structure type', libtcod.struct_get_name(struct), ' named ', name return True def error(self,msg): print 'error : ', msg return True </div>
</div>
            
    <div class="section members">
        <h2>Public Functions</h2>
            <div class="member">
                <div class="name">
                    <span class="type">
                        
                    </span>
                    ~ITCODParserListener
                    <span class="argsstring"> ()</span>
                </div>
                    <div class="description">
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    parserNewStruct
                    <span class="argsstring"> (TCODParser *parser, const TCODParserStruct *str, const char *name)=0</span>
                </div>
                    <div class="description">
        <div class="para">parser_run  Handling 'newStruct' events  This callback is called each time the parser find a new structure declaration in the file. Example : <models.compound.docMarkupType object at 0x7fb3de7eca20> It must return true if everything is right, false if there is an error and the parser must exit.  bool ITCODParserListener::parserNewStruct(TCODParser *parser,TCODParserStruct *str,const char *name)  bool new_struct(TCOD_parser_struct_t str,const char *name)  new_struct(str,name)  parser In the C++ version, the parser object, returned by 
    <a href="classTCODParser.html">TCODParser</a>
 constructor. It's used for error handling.  str The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".  name The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade". </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    parserFlag
                    <span class="argsstring"> (TCODParser *parser, const char *name)=0</span>
                </div>
                    <div class="description">
        <div class="para">parser_run  Handling 'newFlag' events  This callback is called each time the parser find a new flag in the file. Example : <models.compound.docMarkupType object at 0x7fb3deb28f60> It must return true if everything is right, false if there is an error and the parser must exit.  bool 
    <a href="classITCODParserListener_1af974dd420ac692997810a770e95a647c.html">ITCODParserListener::parserFlag(TCODParser *parser,const char *name)</a>
  bool new_flag(const char *name)  new_flag(name)  parser In the C++ version, the parser object, returned by 
    <a href="classTCODParser.html">TCODParser</a>
 constructor. It's used for error handling.  name The name of the flag. In the example, this would be "abstract". </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    parserProperty
                    <span class="argsstring"> (TCODParser *parser, const char *propname, TCOD_value_type_t type, TCOD_value_t value)=0</span>
                </div>
                    <div class="description">
        <div class="para">parser_run  Handling 'newProperty' events  This callback is called each time the parser find a new property in the file. Example : <models.compound.docMarkupType object at 0x7fb3de4a2860> It must return true if everything is right, false if there is an error and the parser must exit.  bool 
    <a href="classITCODParserListener_1a774fd145d75d15179b50539138ec2073.html">ITCODParserListener::parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)</a>
  bool new_property(const char *name, TCOD_value_type_t type, TCOD_value_t value)  new_property(name,type,value)  parser In the C++ version, the parser object, returned by 
    <a href="classTCODParser.html">TCODParser</a>
 constructor. It's used for error handling.  name The name of the property. In the example, this would be "cost".  type The type of the property as defined when you called addProperty or addValueList. In the example, this would be TCOD_TYPE_INT.  value The value of the property, stored in a generic value structure. In the example, we would have value.i == 300. In the case of a value-list property, the type would reflect the list id (between TCOD_TYPE_VALUELIST00 and TCOD_TYPE_VALUELIST15) and value.s would contain the actual string. </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        bool
                    </span>
                    parserEndStruct
                    <span class="argsstring"> (TCODParser *parser, const TCODParserStruct *str, const char *name)=0</span>
                </div>
                    <div class="description">
        <div class="para">parser_run  Handling 'endStruct' events  This callback is called each time the parser find the end of a structure declaration in the file. Example : <models.compound.docMarkupType object at 0x7fb3de910ef0> It must return true if everything is right, false if there is an error and the parser must exit.  bool ITCODParserListener::parserEndStruct(TCODParser *parser,TCODParserStruct *str,const char *name)  bool end_struct(TCOD_parser_struct_t str,const char *name)  end_struct(str,name)  parser In the C++ version, the parser object, returned by 
    <a href="classTCODParser.html">TCODParser</a>
 constructor. It's used for error handling.  str The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".  name The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade". </div>
</div>
            </div>
            <div class="member">
                <div class="name">
                    <span class="type">
                        void
                    </span>
                    error
                    <span class="argsstring"> (const char *msg)=0</span>
                </div>
                    <div class="description">
        <div class="para">parser_run  Handling errors  There are two kind of errors : Errors that are detected by the parser itself (malformed file, bad value syntax for a property, missing mandatory property in a structure, ...). Errors that you detect in your callbacks. When the parser finds an error in the file, it will call the error callback and stop :  void 
    <a href="classITCODParserListener_1ad81eca4f32c9411d5b82405f261f9c95.html">ITCODParserListener::error(const char *msg)</a>
  void 
    <a href="classITCODParserListener_1ad81eca4f32c9411d5b82405f261f9c95.html">error(const char *msg)</a>
  error(msg)  msg The error message from the parser with the file name and the line number.  parser_run  If you find an error in your callback, you have to call the parser error function. It will add the file name and line number to your error message, and then call your error callback : The code in the example below will result in your error callback called with the following string : "error in &lt;filename&gt; line &lt;line_number&gt; : Bad cost value %d. Cost must be between 0 and 1000"  void 
    <a href="classTCODParser_1abab3467962cdb26014d539c230fd2775.html">TCODParser::error</a>
(const char *msg, ...)  void TCOD_parser_error(const char *msg, ...)  parser_error(msg)  msg printf-like format string for your error message.  parser->error("Bad cost value %d. Cost must be between 0 and 1000", value.i);  TCOD_parser_error("Bad cost value %d. Cost must be between 0 and 1000", value.i);  libtcod.parser_error("Bad cost value %d. Cost must be between 0 and 1000"%( value )) </div>
</div>
            </div>
    </div>

    </div>

            </div>
        </body>
    </html>
